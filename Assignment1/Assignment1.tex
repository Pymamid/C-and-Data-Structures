\documentclass[a4paper]{article} 
\usepackage{listings}
\lstset{language=C}
\begin{document}

%-------------------------------
%	TITLE SECTION
%-------------------------------


\hrule \medskip % Upper rule
\begin{minipage}{0.295\textwidth} 
\raggedright
\footnotesize
Pragna Mamidipaka \hfill\\   
EE20BTECH11026\hfill\\
ee20btech11026@iith.ac.in
\end{minipage}
\begin{minipage}{0.4\textwidth} 
\centering 
\large 
Assignment 1\\ 
\normalsize 
C and Data Structures\\ 
\end{minipage}
\begin{minipage}{0.295\textwidth} 
\raggedleft
\today\hfill\\
\end{minipage}
\medskip\hrule 
\bigskip

%-------------------------------
%	CONTENTS
%-------------------------------

\section*{Question}

Consider the following C program:
\begin{lstlisting}
#include<stdio.h>
void fun1(char *s1, char *s2){
    char *tmp;
    tmp = s1;
    s1 = s2;
    s2 = tmp;
}
void fun2(char **s1, char **s2){
    char *tmp;
    tmp = *s1;
    *s1 = *s2;
    *s2 = tmp;
}
int main(){
    char *str1 = "Hi", *str2 = "Bye";
    fun1(str1, str2); printf("%s %s ", str1, str2);
    fun2(&str1, &str2); printf("%s %s", str1, str2);
    return 0;
}

\end{lstlisting}
The output of the program above is:
\bigbreak
\section*{Answer}
The output of the above program is:
Hi Bye Bye Hi

The function fun1 is call-by-value. In this mechanism, the values of actual parameters get copied to formal parameters and the modifications performed on formal parameters will not be updated on actual parameters.
Therefore, str1 and str2 still point to their old values.

The function fun2 is call-by-reference. In this mechanism, the address of actual parameters get copied to formal parameters. Therefore, the modifications performed via formal parameters will be updated on actual parameters.
Therefore, the values in str1 and str2 get interchanged by calling the second function.

\end{document}
